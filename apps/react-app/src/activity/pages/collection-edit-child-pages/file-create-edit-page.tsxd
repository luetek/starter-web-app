/* eslint-disable react-hooks/exhaustive-deps */
import { useSelector } from 'react-redux';
import { useNavigate, useParams } from 'react-router-dom';
import axios from 'axios';
import { ChangeEvent, useEffect, useMemo, useState } from 'react';
import Modal from 'react-bootstrap/Modal';
import InputGroup from 'react-bootstrap/InputGroup';
import Form from 'react-bootstrap/Form';
import Button from 'react-bootstrap/Button';
import { MarkdownComponent } from '../../components/markdown-component';
import { RootState, useAppDispatch } from '../../../store';
import { getActivityCollectionThunk } from '../../activity-collection-slice';
import { cleanUpFile, persistExistingFile, persistNewFile, updateFileCacheContent } from '../../file-storage-slice';
import { CodeMirrorComponent } from '../../components/code-mirror-component';
import { FileType, getTypeFromFileName, fileExtension } from '../../constants';

<Route path="activities/:activityId/files/:fileId/edit" element={<FileCreateOrUpdate />} />;
<Route path="activities/:activityId/files/create/:fileType" element={<FileCreateOrUpdate />} />
export function FileCreateOrUpdate() {
  const [fileName, setFileName] = useState(''); // Contains fileName with Extension
  const [fileTypeSelected, setFileTypeSelected] = useState<FileType | undefined>();
  const [fileNameDialog, setFileNameDialog] = useState(false);
  const [dialogButtonDisabled, setDialogButtonDisabled] = useState(false);

  const dispatch = useAppDispatch();
  const navigate = useNavigate();
  const activityCollection = useSelector((state: RootState) => state.activityCollection.current);
  const files = useSelector((state: RootState) => state.fileCache.files);
  // fileType is optional param avaiable in create path
  const { activityId, fileId, fileType } = useParams();

  const activity = activityCollection?.activities?.filter((act) => act.id === parseInt(activityId as string, 10))[0];
  const file = activity?.parent?.children?.filter((ff) => ff.id === (fileId ? parseInt(fileId, 10) : null))[0];
  // Update whenever path is is changed
  const tmpKey = useMemo(() => {
    if (!fileId) return `//tmp/${activityId}/${fileType}`;
    return `//files/${activityId}/fileId-${fileId}`;
    console.log('tmpKey Evaluated');
  }, [fileId, activityId, fileType]);

  // One time load only
  const fileDataInitial = useMemo(() => {
    const ff = files.filter((f) => f.fileName === tmpKey)[0] || {
      data: '',
      fileName: tmpKey,
      lastAccessed: Date.now(),
      version: 0,
    };
    console.log(tmpKey);
    console.log('Reloading fileData');
    console.log(ff);
    return ff;
  }, [tmpKey]);

  useEffect(() => {
    const loadFile = async () => {
      if (file) {
        const res = await axios.get(`api/storage/${file?.parentId}/stream/${file?.name}`, { responseType: 'stream' });
        let str = '';
        const chunks = res.data;
        for await (const chunk of chunks) {
          str += chunk;
        }
        // Redux will either load this content or ignore this as we might have some uptodate content.
        // We may want a button to reset the local content.

        // dispatch(saveFileContent({ data: str, fileName: tmpKey, lastAccessed: Date.now(), version: file.version }));
      }
    };
    if (file) {
      setFileName(file.name);
      loadFile();
      setFileTypeSelected(getTypeFromFileName(file.name));
    } else {
      setFileTypeSelected(fileType as any);
    }
  }, [file, fileType]); // We want to load when file change occurs in the url.

  if (!activityCollection || !activity || !fileTypeSelected) return 'Loading';

  // Does the actual saving of the fileName, assumes fileName is available.
  const onSaveHandler = async () => {
    const fileRes = file
      ? await dispatch(persistExistingFile({ fileId: file.id, fileName: file?.name, fileKey: tmpKey })).unwrap()
      : await dispatch(persistNewFile({ folderId: activity.parent.id, fileName, fileKey: tmpKey })).unwrap();
    // reload the data
    await dispatch(getActivityCollectionThunk(activityCollection.id));
    await dispatch(cleanUpFile(tmpKey));
    // navigate(`/activity-collections/${activityCollection.id}/activities/${activityId}/files/${fileRes.id}/edit`);
  };

  // Called when click save on the dialog modal button
  const onSaveDailogBtnClickHandler = async () => {
    setDialogButtonDisabled(true);
    await onSaveHandler();
    setDialogButtonDisabled(false);
    setFileNameDialog(false);
  };

  const showSaveModalOrSaveContent = async () => {
    if (fileId) {
      await onSaveHandler();
    } else {
      setFileNameDialog(true);
    }
  };

  return (
    <div>
      <div> {!fileId ? `Create ${fileTypeSelected}` : `Edit ${fileName}`} </div>
      <Modal show={fileNameDialog} onHide={() => setFileNameDialog(false)} animation={false}>
        <Modal.Header closeButton>
          <Modal.Title>Modal heading</Modal.Title>
        </Modal.Header>
        <Modal.Body>
          <InputGroup className="mb-3">
            <InputGroup.Text>file Name</InputGroup.Text>
            <Form.Control
              aria-label="filename without the extension"
              onChange={(e: ChangeEvent<HTMLInputElement>) => {
                e.preventDefault();
                // TODO:: Add Error Handling
                setFileName(`${e.target.value}.${fileExtension[fileTypeSelected]}`);
              }}
            />
            <InputGroup.Text>.{fileExtension[fileTypeSelected]}</InputGroup.Text>
          </InputGroup>
        </Modal.Body>
        <Modal.Footer>
          <Button variant="secondary" onClick={() => setFileNameDialog(false)}>
            Close
          </Button>
          <Button variant="primary" disabled={dialogButtonDisabled} onClick={onSaveDailogBtnClickHandler}>
            Save Changes
          </Button>
        </Modal.Footer>
      </Modal>
      {fileTypeSelected === FileType.MARKDOWN ? (
        <MarkdownComponent
          content={fileDataInitial.data}
          parent={activity.parent}
          isEditor
          onChange={(txt) => {
            /*
            dispatch(
              saveFileContent({
                data: txt,
                fileName: tmpKey,
                lastAccessed: Date.now(),
                version: fileDataInitial.version,
              })
            ); */
          }}
          onSave={showSaveModalOrSaveContent}
        />
      ) : null}
      {fileTypeSelected === 'python' ? (
        <CodeMirrorComponent
          content={fileDataInitial.data}
          fileType={fileTypeSelected}
          onSave={showSaveModalOrSaveContent}
          onChange={(txt) => {
            console.log(txt);
            /*
            dispatch(
              saveFileContent({
                data: txt,
                fileName: tmpKey,
                lastAccessed: Date.now(),
                version: fileDataInitial.version,
              })
            ); */
          }}
        />
      ) : null}
    </div>
  );
}
